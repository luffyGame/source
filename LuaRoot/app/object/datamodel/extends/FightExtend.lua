---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangliang.
--- DateTime: 2018/4/11 下午6:16
---

local ipairs,pairs = ipairs,pairs
local Insert,Remove = table.insert,table.remove
local math = math
local Max,Min,Exact3,Floor = math.max,math.min,math.exact3,math.floor
local EqualZero = Math.EqualZero
local Const = Const
local props = Const.Props
local PropHpIdx,PropAtkIdx,PropCount = Const.PropHpIdx,Const.PropAtkIdx,#props
local PropAtk = props[PropAtkIdx]

local Skill = require("app.module.skill.Skill")

local propMods = {}
local function __initProps()
    for i,prop in ipairs(props) do
        propMods[i] = prop.."Mod"
    end
end
__initProps()

local saveFields = {"nowHp","dead"}

local FightExtend= {}

function FightExtend:MarkFightSave(saveProps)
    if saveProps then
        for i=1,PropCount do
            if self:HasProp(i) then
                self:MarkOneFieldSave(props[i])
                self:MarkOneFieldSave(propMods[i])
            end
        end
    end
    self:MarkFieldSave(saveFields)
end

function FightExtend:ResetProp(recoverHp)
    for i,prop in ipairs(props) do
        if self:HasProp(i) then
            self:SetValue(prop,self:GetBaseProp(prop))
        end
    end
    if recoverHp then
        self:SetValue("nowHp",self.hp)
    end
end
function FightExtend:GetBaseProp(prop)
end
function FightExtend:HasProp(propIdx)
    return true
end
--增加值
function FightExtend:AddPropVal(propIdx,val)
    if not val or val == 0 or not self:HasProp(propIdx) then return end
    local propMod = propMods[propIdx]
    local mod = self[propMod] or {0,0}
    mod[1] = mod[1] + val
    self:SetValue(propMod,mod,true)
    self:UpdatePropValue(propIdx)
end
--增加百分比
function FightExtend:AddPropPec(propIdx,pec)
    if not pec or pec == 0 or not self:HasProp(propIdx) then return end
    local propMod = propMods[propIdx]
    local mod = self[propMod] or {0,0}
    mod[2] = mod[2] + pec
    self:SetValue(propMod,mod,true)
    self:UpdatePropValue(propIdx)
end

function FightExtend:UpdatePropValue(propIdx)
    if propIdx == PropAtkIdx then return end --对于攻击，由技能叠加而成，此处不必计算
    local prop = props[propIdx]
    local base = self:GetBaseProp(prop)
    if not base then return end
    local mod = self[propMods[propIdx]] or {0,0}
    local newVal = Max(0,(base + mod[1])*(1+mod[2]))
    self:SetValue(prop,Floor(newVal))
    if propIdx == PropHpIdx then --改变最大血量
        self:SetValue("nowHp",Min(self.nowHp,self.hp))
    end
end

function FightExtend:GetHpRate()
    return self.nowHp/self.hp
end

function FightExtend:GetCamp() end

function FightExtend:GetMutexBuff(mutex)
    if not self.buffs then return end
    for _,buff in ipairs(self.buffs) do
        if buff:GetMutex() == mutex then
            return buff
        end
    end
end

function FightExtend:GetBuff(buffId,srcId)
    if not self.buffs then return end
    for _,buff in ipairs(self.buffs) do
        if buff.id == buffId and buff.srcId == srcId then
            return buff
        end
    end
end

function FightExtend:AddBuff(buff)
    if not self.buffs then self.buffs = {} end
    Insert(self.buffs,buff)
end

function FightExtend:UpdateFight(deltaTime)
    if self.skills then
        for _,skill in pairs(self.skills) do
            skill:Update(deltaTime)
        end
    end

    local buffCount = self.buffs and #self.buffs or 0
    if buffCount == 0 then return end
    for _,buff in ipairs(self.buffs) do
        buff:Update(deltaTime)
    end
    for i=buffCount,1,-1 do
        local buff = self.buffs[i]
        if buff.isOver then
            Remove(self.buffs,i)
            buff:Detach()
        end
    end
end

function FightExtend:DecHp(delta)
    local newHp = Max(0,self.nowHp-delta)
    self:SetValue("nowHp",newHp)
    if EqualZero(newHp) then
        self:OnDead()
        self:SetValue("dead",true)
    end
end

function FightExtend:IncHp(delta)
    local newHp = Min(self.nowHp+delta,self.hp)
    self:SetValue("nowHp",newHp)
end

function FightExtend:AddHp(delta)
    if delta>0 then
        self:IncHp(delta)
    else
        self:DecHp(delta)
    end
end

function FightExtend:AddHpPec(pec)
    self:AddHp(Floor(self.hp*pec))
end

function FightExtend:OnDead() end

function FightExtend:Relive()
    self:ResetProp(true)
    self:SetValue("dead",false)
end

function FightExtend:GetHp()
    return self.hp
end

function FightExtend:GetNowHp()
    return self.nowHp
end

function FightExtend:GetDef()
    return self.def or 0
end
--命中,灵活
function FightExtend:GetAgl()
    return self.agl or 0
end
--闪避,敏捷
function FightExtend:GetDex()
    return self.dex or 0
end

function FightExtend:GetMiss()
    return self.miss or 0
end

function FightExtend:GetDmgInc()
    return self.damageIncrease or 0
end

function FightExtend:GetDmgDec()
    return self.damageReduction or 0
end

function FightExtend:GetAtk(atkAdd)
    local base = (self:GetBaseProp(PropAtk) or 0) + atkAdd
    local mod = self.atkMod
    if not mod then return base end
    return Max(0,(base + mod[1])*(1+mod[2]))
end

function FightExtend:GetAtkTrue()
    return self.atkTrue or 0
end

function FightExtend:GetCrit()
    return self.crit
end

function FightExtend:GetSkill(skillId,notGen)
    if not self.skills then
        if notGen then return end
        self.skills = {}
    end
    local skill = self.skills[skillId]
    if not skill and not notGen then
        skill = Skill.new(skillId)
        self.skills[skillId] = skill
    end
    return skill
end

return FightExtend