---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangliang.
--- DateTime: 2018/5/2 下午4:15
---
local math = math
local sqrt,sin,cos,abs = math.sqrt,math.sin,math.cos,math.abs
local tostring = tostring
local bind = require("xlua.util").bind
local Vector3 = Vector3
local Camp = Const.Camp

local SkillArea,SkillAreaPivot = Const.SkillArea,Const.SkillAreaPivot
local getLinkedAoi,getBlockAoi = Global.GetLinkedAoi,Global.GetBlockAoi

local target_entity_calc_func,target_pos_calc_func = {},{}

local warn_res =
{
    [2] = "warn_rect",
    [3] = "warn_circle",
    [4] = "warn_fan_",
    fan = {},
    GetFanRes = function(self,areaType,angle)
        if areaType == SkillArea.FAN then
            if not self.fan[angle] then
                self.fan[angle] = self[areaType]..tostring(angle)
            end
            return self.fan[angle]
        else
            return self[areaType]
        end
    end,
}

local SkillTargetSelector = class("SkillTargetSelector")

local pivotLocFunc = {}

pivotLocFunc[SkillAreaPivot.SELF] = function(self,calc)
    calc.pivot = calc.user
end
pivotLocFunc[SkillAreaPivot.TARGET] = function(self,calc)
    if calc.originT and calc.originT.isEntity then
        calc.pivot = calc.originT
    else
        print("originT must be target")
    end
end
pivotLocFunc[SkillAreaPivot.POS] = function(self,calc)
    if calc.originT and not calc.originT.isEntity then
        calc.pivot = calc.originT
    else
        print("originT must be pos")
    end
end
pivotLocFunc[SkillAreaPivot.TARGET_POS_1] = function(self,calc)
    if calc.originT and calc.originT.isEntity then
        calc.pivot = calc.originT:GetPos()
    else
        print("originT must be target")
    end
end
pivotLocFunc[SkillAreaPivot.TARGET_POS_2] = pivotLocFunc[SkillAreaPivot.TARGET_POS_1]

pivotLocFunc[SkillAreaPivot.SELF_POS] = function(self,calc)
    calc.pivot = calc.user:GetPos()
end

function SkillTargetSelector:ctor(skill)
    self.skill = skill
    self.areaType = skill:GetAreaType()
    self.areaPivot = skill:GetAreaPivot()
    if self.areaType == SkillArea.CIRCLE then
        self.radius = skill:GetAreaParam()[1]
    elseif self.areaType == SkillArea.RECT then
        local param = skill:GetAreaParam()
        self.width = param[1]
        self.length = param[2]
        self.radius = sqrt(self.width*self.width + self.width*self.width)
    elseif self.areaType == SkillArea.FAN then
        local param = skill:GetAreaParam()
        self.radius = param[1]
        self.angle = param[2]
    end
end

function SkillTargetSelector:OnStart(calc)
    if self.areaPivot ~= SkillAreaPivot.TARGET_POS_2 then
        pivotLocFunc[self.areaPivot](self,calc)
        self:Warn(calc)
    end
end

function SkillTargetSelector:OnFirstHit(calc)
    if self.areaPivot == SkillAreaPivot.TARGET_POS_2 then
        pivotLocFunc[self.areaPivot](self,calc)
        self:Warn(calc)
    end
    self:ReachTest(calc)
end

function SkillTargetSelector:Warn(calc)
    if self.skill:ShowWarn() and self.areaType ~= SkillArea.POINT and calc.pivot then
        local xScale,zScale
        if self.areaType == SkillArea.CIRCLE then
            xScale = self.radius*2
            zScale = xScale
        elseif self.areaType == SkillArea.RECT then
            xScale = self.width
            zScale = self.length
        elseif self.areaType == SkillArea.FAN then
            xScale = self.radius*2
            zScale = xScale
        end
        calc:ShowWarn(warn_res:GetFanRes(self.areaType,self.angle),Vector3.new(xScale,1,zScale),rot)
    end
end

---判断技能是否到达目标，并给出技能的终点位置
function SkillTargetSelector:ReachTest(calc)
    local user = calc.user
    local pivot = calc.pivot
    if not pivot then return end
    if pivot == user then
        calc.reached = true
        calc.pos = user:GetPos()
    else
        local skillRange = self.skill:GetRange()
        if pivot.isEntity then
            calc.reached,calc.pos = user:CanSkillReachEntity(pivot,skillRange)
        else
            calc.reached,calc.pos = user:CanSkillReachPos(pivot,skillRange)
        end
    end
end

function SkillTargetSelector:CalcPointTarget(target)
    if target and target.isEntity then
        self:AddTarget(target)
    end
end

function SkillTargetSelector:CalcAreaTarget(target)
    self.out.target = {}
    if target.isEntity then
        local calcFunc = target_entity_calc_func[self.areaType]
        calcFunc(self,target)
    else
        local calcFunc = target_pos_calc_func[self.areaType]
        calcFunc(self,target)
    end
end

---计算目标，传入的target可能是
function SkillTargetSelector:CalcTarget(calc)
    calc.targetCount = 0
    local pivot = calc.pivot
    if not pivot then return end
    self.out = calc
    if self.areaType == SkillArea.POINT then
        if calc.reached then
            self:CalcPointTarget(pivot)
        end
    else
        if calc.reached then
            self:CalcAreaTarget(pivot)
        else
            self:CalcAreaTarget(calc.pos)
        end
    end
    self.out = nil
end

function SkillTargetSelector:IsSkillTarget(entity)
    if entity == self.out.user and not self.skill:IsUnDiff() then
        return false
    end
    if not Camp:IsEnemy(entity:GetCamp(),self.out.user:GetCamp()) then
        return false
    end
    if self.skill.isProduce then
        if not entity.isItem then return false end
    else
        if entity.isItem then return false end
    end
    return not entity:IsDead()
end

function SkillTargetSelector:GetSelectFilter(selectCb)
    if not self.selectFilter then
        self.selectFilter = bind(selectCb,self)
    end
    return self.selectFilter
end

function SkillTargetSelector:CircleCb(entity)
    if not self:IsSkillTarget(entity) then return end
    self:AddTarget(entity)
end

function SkillTargetSelector:RectCb(entity,delta)
    if not self:IsSkillTarget(entity) then return end
    if not delta then
        self:AddTarget(entity)
    else
        delta:yRotate(self.yCos,self.ySin)
        if delta.x < 0 or delta.x > self.length then return end
        if abs(delta.z) > self.width/2 then return end
        self:AddTarget(entity)
    end
end

function SkillTargetSelector:FanCb(entity,delta)
    if not self:IsSkillTarget(entity) then return end
    if not delta then
        self:AddTarget(entity)
    else
        local angleD = abs(Vector3.Angle1(self.casterDir,delta))
        if angleD <= self.angle then
            self:AddTarget(entity)
        end
    end
end

function SkillTargetSelector:AddTarget(entity)
    self.out:AddTarget(entity)
end
---region 以目标实体为轴点的区域计算
function SkillTargetSelector:CalcEntityCircle(entity)
    getLinkedAoi():GetInCircle(entity,self.radius,self:GetSelectFilter(self.CircleCb))
end

function SkillTargetSelector:CalcEntityRect(entity)
    local casterYRad = self.out.user:GetYRad()
    self.yCos = cos(-casterYRad)
    self.ySin = sin(-casterYRad)
    getLinkedAoi():GetInCircle(entity,self.radius,self:GetSelectFilter(self.RectCb))
end


function SkillTargetSelector:CalEntityFan(entity)
    self.casterDir = self.out.user:GetDir()
    getLinkedAoi():GetInCircle(entity,self.radius,self:GetSelectFilter(self.FanCb))
end
target_entity_calc_func[SkillArea.CIRCLE] = SkillTargetSelector.CalcEntityCircle
target_entity_calc_func[SkillArea.RECT] = SkillTargetSelector.CalcEntityRect
target_entity_calc_func[SkillArea.FAN] = SkillTargetSelector.CalEntityFan
---endregion

---region 以位置为轴点的区域计算
function SkillTargetSelector:CalcPosCircle(pos)
    getBlockAoi():GetInCircle(pos,self.radius,self:GetSelectFilter(self.CircleCb))
end

function SkillTargetSelector:CalcPosRect(pos)
    local casterYRad = self.out.user:GetYRad()
    self.yCos = cos(-casterYRad)
    self.ySin = sin(-casterYRad)
    getBlockAoi():GetInCircle(pos,self.radius,self:GetSelectFilter(self.RectCb))
end


function SkillTargetSelector:CalPosFan(pos)
    self.casterDir = self.out.user:GetDir()
    getBlockAoi():GetInCircle(pos,self.radius,self:GetSelectFilter(self.FanCb))
end
target_pos_calc_func[SkillArea.CIRCLE] = SkillTargetSelector.CalcPosCircle
target_pos_calc_func[SkillArea.RECT] = SkillTargetSelector.CalcPosRect
target_pos_calc_func[SkillArea.FAN] = SkillTargetSelector.CalPosFan
---endregion
return SkillTargetSelector